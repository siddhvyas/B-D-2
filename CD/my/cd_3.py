# -*- coding: utf-8 -*-
"""CD_3

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1gATpXkM8nAOjDnNgDVF9PB_ccXpUCyHY
"""

expr = 'e = a + b * (c - d)'

import re

def tokenize(expr):
  return re.findall(r'\w+|[+\-*/()=]', expr)

print(tokenize(expr))

precedence = { '+': 1, '-': 1, '*': 2, '/': 2}

def infix_to_postfix(tokens):
  postfix, stack = [], []
  for token in tokens:
    if token.isalnum():
      postfix.append(token)
    elif token == '(':
      stack.append(token)
    elif token == ')':
      while stack[-1] != '(':
        postfix.append(stack.pop())
      stack.pop()
    else:
      while stack and (precedence.get(stack[-1], 0) >= precedence.get(token, 0)):
          postfix.append(stack.pop())
      stack.append(token)
  return postfix + stack[::-1]

def generate_tac(expr):
  target, exp = expr.split('=')
  tokens = tokenize(exp)
  postfix = infix_to_postfix(tokens)
  return postfix_to_tac(postfix, target)

def postfix_to_tac(postfix, target):
  temp_count = 0
  code, stack = [], []
  for token in postfix:
    if token.isalnum():
      #print(stack, code)
      stack.append(token)
    else:
      #print(stack, code)
      b, a = stack.pop(), stack.pop()
      code.append(f'T{temp_count} = {a} {token} {b}')
      stack.append(f'T{temp_count}')
      temp_count += 1
  code.append(f'{target} = {stack.pop()}')
  return code

codes = generate_tac(expr)
for code in codes:
  print(code)

def generate_quad(expr):
  target, exp = expr.split('=')
  tokens = tokenize(exp)
  postfix = infix_to_postfix(tokens)
  return postfix_to_quad(postfix, target)

def postfix_to_quad(postfix, target):
  quadruples, stack = [], []
  t_count = 0
  for token in postfix:
    if token.isalnum():
      stack.append(token)
    else:
      b, a = stack.pop(), stack.pop()
      quadruples.append([f'T{t_count}', token, a, b])
      stack.append(f'T{t_count}')
      t_count += 1
  quadruples.append([target, '=', stack.pop(), ''])
  return quadruples

quads = generate_quad(expr)
print(f'{"Result":<10}{"Operator":<10}{"Operand1":<10}{"Operand2":<10}')
for quad in quads:
  print(f'{quad[0]:<10}{quad[1]:<10}{quad[2]:<10}{quad[3]:<10}')

def generate_triples(expr):
  target, exp = expr.split('=')
  tokens = tokenize(exp)
  postfix = infix_to_postfix(tokens)
  return postfix_to_triples(postfix)

def postfix_to_triples(postfix):
  triples, stack = [], []
  t_count = 0
  for token in postfix:
    if token.isalnum():
      stack.append(token)
    else:
      b, a = stack.pop(), stack.pop()
      triples.append([token, a, b])
      stack.append(f'{t_count}')
      t_count += 1
  triples.append(['=', stack.pop(), ''])
  return triples

triples = generate_triples(expr)
print(f'{"Operator":<10}{"Operand1":<10}{"Operand2":<10}')
for triple in triples:
  print(f'{triple[0]:<10}{triple[1]:<10}{triple[2]:<10}')

